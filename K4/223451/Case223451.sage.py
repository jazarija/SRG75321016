# This file was *autogenerated* from the file Case223451.sage
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_17 = Integer(17); _sage_const_16 = Integer(16); _sage_const_15 = Integer(15); _sage_const_14 = Integer(14); _sage_const_22 = Integer(22); _sage_const_19 = Integer(19); _sage_const_18 = Integer(18)
sage.repl.load.load(sage.repl.load.base64.b64decode("Li4vLi4vZ2VuZXJpY1NSRy5zYWdl"),globals(),False)
from itertools import product, combinations

global cann
cann = set()

def fixGraph(G):

    for v in (ellipsis_range(_sage_const_0 ,Ellipsis,_sage_const_14 )):
        deg = G.subgraph((ellipsis_range(_sage_const_0 ,Ellipsis,_sage_const_14 ))).degree(v)
        if deg == _sage_const_2 :
            G.add_edge(v, _sage_const_18 )

        if deg == _sage_const_0  and not G.has_edge(v, _sage_const_17 ): 
            return []

        if deg == _sage_const_1  and G.has_edge(v, _sage_const_17 ):
            G.add_edge(v, _sage_const_18 )

    if isInterlacedFast(G):
        return [G]

    return []

L = []
for G in graphs.nauty_geng("15 -D2"):

    # 15 = x_0, 16 = x_1
    G.add_vertices([_sage_const_15 , _sage_const_16 ])


    for x in (ellipsis_range(_sage_const_0 ,Ellipsis,_sage_const_14 )):
        G.add_edge(x, _sage_const_15 )

    if not isInterlacedFast(G):
        continue

    # 17 = x_3
    # 18 = x_1'
    G.add_edge(_sage_const_17 , _sage_const_16 ) 
    G.add_edge(_sage_const_17 , _sage_const_15 ) 
    G.add_edge(_sage_const_18 , _sage_const_16 )

    # we cover two options based on whether x_3 and x_1' are adjacent or not

    H = G.copy()
    I = H.copy()

    # not adjacent 
    L += [I]

    # adjacent
    H.add_edge(_sage_const_18 , _sage_const_17 )
        
    candNbr = [v for v in (ellipsis_range(_sage_const_0 ,Ellipsis,_sage_const_14 )) if G.subgraph((ellipsis_range(_sage_const_0 ,Ellipsis,_sage_const_14 ))).degree(v) <= _sage_const_1 ]

    for nbr in candNbr:
        I = H.copy()
        # note, nbr may still be adjacent to x_1'
        I.add_edge(_sage_const_17 , nbr)
        L += [I]


print "We have obtained", len(L), "candidate graphs. We will add edges between x_0', x_1 and X_2^0 now."


L2 = []
for G in L:
    L2 += fixGraph(G)

print 'We got', len(L2), 'candidate graphs. We will add K_4 now.'

def extendVertex(G,v, toFix):
    global cann

    ret = []

    if v == _sage_const_15  or v == _sage_const_16 :
        t = _sage_const_0 
    elif v == _sage_const_17 :
        t = _sage_const_3 
    elif v == _sage_const_18 :
        t = _sage_const_1 
    else:
        t = _sage_const_2 

    for nbr in combinations((ellipsis_range(_sage_const_19 ,Ellipsis,_sage_const_22 )), t):
        H = G.copy()
        H.add_edges( (v, el) for el in nbr)
        s = H.canonical_label(partition=[(ellipsis_range(_sage_const_0 ,Ellipsis,_sage_const_14 )),[_sage_const_15 ,_sage_const_16 ],[_sage_const_17 ],[_sage_const_18 ],(ellipsis_range(_sage_const_19 ,Ellipsis,_sage_const_22 ))]).graph6_string()
        if s not in cann:
            cann.add(s)
            X = H.subgraph( set(H) - set(toFix) )
            X.relabel()
            if isInterlacedFast(X):
                ret += [H]
    return ret     

# We obtain a graph with 19 vertices we add vertices [19,20,21,22] representing
# K_4. The vertices [14,15] then need 3 vertices in K_4, 16,17 need a singe vertex in K_4
# and the vertices 0..13 need 2 vertices in K_4
def extend(G):

    G.add_edges( Combinations( (ellipsis_range(_sage_const_19 ,Ellipsis,_sage_const_22 )), _sage_const_2 ) )
    generated = [G]
    toFix = (ellipsis_range(_sage_const_0 ,Ellipsis,_sage_const_18 )) 

    while toFix:
        v = toFix.pop()
        generated_tmp = []
        for G in generated:
            generated_tmp += extendVertex(G, v, toFix)
        generated = generated_tmp
        print len(generated), len(toFix)
    return generated

L3 = []
for G in L2:
    L3+=extend(G)
print 'We got', len(L3), 'candidate graphs.'

